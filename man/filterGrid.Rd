% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/filterGrid.R
\name{filterGrid}
\alias{filterGrid}
\title{Time filtering}
\usage{
filterGrid(grid, window.width, method = c("convolution", "recursive"),
  sides = 1, parallel = FALSE, max.ncores = 16, ncores = NULL, ...)
}
\arguments{
\item{grid}{Input grid (possibly multimember)}

\item{window.width}{An integer specifying the moving window width. This is in the same temporal units 
as the input grid. The function internally converts this value to a vector of filter coefficients of the
form \code{rep(1/n,n)}. See \code{\link{filter}} for details.}

\item{method}{Either \code{"convolution"} or \code{"recursive"}. The \code{"convolution"}
option (Default) performs a \emph{moving average}, while \code{"recursive"} applies an autoregressive model.
See \code{\link{filter}} for details.}

\item{sides}{Used for \code{"convolution"} filters only. If \code{sides = 1} the filter coefficients
are for past values only; if \code{sides = 2} they are centred around lag 0.
See \code{filter} for more details.}

\item{parallel}{Logical. Should parallel execution be used?}

\item{max.ncores}{Integer. Upper bound for user-defined number of cores.}

\item{ncores}{Integer number of cores used in parallel computation. Self-selected number of
cores is used when \code{ncpus = NULL} (the default), or when \code{maxcores} exceeds the default \code{ncores} value.}

\item{...}{Further arguments passed to \code{filter}. Worth to mention here the \code{circular} argument,
used in moving averages. See \code{\link{filter}} for details.}
}
\value{
A time-filtered grid.
}
\description{
Apply a filter along the time dimension of a grid
}
\details{
A wrapper of function \code{\link{filter}}
}
\section{Parallel Processing}{


Parallel processing is enabled using the \pkg{parallel} package. 
Parallelization is undertaken by a FORK-type parallel socket cluster formed by \code{ncores}.
If \code{ncores} is not specified (default), \code{ncores} will be one less than the autodetected number of cores.
The maximum number of cores used for parallel processing can be set with the \code{max.ncores} argument, 
although this will be reset to the auto-detected number of cores minus 1 if this number is exceeded. Note that not all 
code, but just some critical loops within the function are parallelized.

In practice, parallelization does not always result in smaller execution times, due to the parallel overhead.
However, parallel computing may potentially provide a significant speedup for the 
particular case of large multimember datasets or large grids.
 
Parallel computing is currently not available for Windows machines.
}
\examples{
data(iberia_ncep_ta850)
plot(iberia_ncep_ta850[["Data"]][,3,3], ty = 'l')
# Apply a moving average considering 2 different window widths of 30 and 90 days
fgrid30 <- filterGrid(iberia_ncep_ta850, method = "convolution", window.width = 30, sides = 1)
lines(fgrid30[["Data"]][,3,3], col = 'red')
fgrid90 <- filterGrid(iberia_ncep_ta850, method = "convolution", window.width = 90, sides = 1)
lines(fgrid90[["Data"]][,3,3], col = 'green')
legend("top", c("raw","30-day MA", "90-day MA"), lty = 1, col = c(1,2,3), ncol = 3)
}
\author{
J Bedia
}

