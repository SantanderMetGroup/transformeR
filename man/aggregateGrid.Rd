% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/aggregateGrid.R
\name{aggregateGrid}
\alias{aggregateGrid}
\title{Grid aggregation along selected dimensions}
\usage{
aggregateGrid(grid, aggr.mem = list(FUN = NULL), aggr.d = list(FUN = NULL),
  aggr.m = list(FUN = NULL), aggr.y = list(FUN = NULL),
  aggr.lat = list(FUN = NULL), weight.by.lat = FALSE, aggr.lon = list(FUN
  = NULL), parallel = FALSE, max.ncores = 16, ncores = NULL)
}
\arguments{
\item{grid}{a grid or multigrid to be aggregated.}

\item{aggr.mem}{Same as \code{aggr.d}, but indicating the function for computinh the member aggregation.}

\item{aggr.d}{Daily aggregation function (for sub-daily data only). A list indicating the name of the
aggregation function in first place, and other optional arguments to be passed to the aggregation function. See the examples.}

\item{aggr.m}{Same as \code{aggr.d}, but indicating the monthly aggregation function.}

\item{aggr.y}{Same as \code{aggr.d}, but indicating the annual aggregation function.}

\item{aggr.lat}{Same as \code{aggr.d}, indicating the aggregation function to be applied along latitude.}

\item{weight.by.lat}{Logical. Should latitudinal averages be weighted by the cosine of latitude?.
Default to \code{FALSE}. Ignored if no \code{aggr.lat} function is indicated, or a function different from \code{"mean"}
is applied.}

\item{aggr.lon}{Same as \code{aggr.lat}, but for longitude.}

\item{parallel}{Logical. Should parallel execution be used?}

\item{max.ncores}{Integer. Upper bound for user-defined number of cores.}

\item{ncores}{Integer number of cores used in parallel computation. Self-selected number of
cores is used when \code{ncpus = NULL} (the default), or when \code{maxcores} exceeds the default \code{ncores} value.}
}
\value{
A grid or multigrid aggregated along the chosen dimension(s).
}
\description{
Aggregates a grid along the target dimensions through aggregation function specification.
}
\details{
\strong{Aggregation function definition}

The aggregation functions are specified in the form of a named list of the type \code{FUN = "function", ...}, where
\code{...} are further arguments passes to FUN. This allows for a flexible definition of aggregation functions, that are
internally passes to \code{\link{tapply}}. Note that the name of the function is indicated as a character string.

\strong{Member aggregation}

The function preserves the metadadata associated with member information (i.e. initialization dates and member names) after
aggregation. In addition, an attribute indicating the member aggregation function is added to the \code{Variable} component.


\strong{Temporal aggregation}

To annually or monthly aggregate data, \code{aggr.d} and/or \code{aggr.m} functions are specified.
Aggregatikons need to be specified from bottom to top, so for instance, if the data in the grid is sub-daily
and \code{aggr.d} is not specified, an error will be given for monthly or annual aggregation requests. Similarly,
annual aggregations require a previous specification of daily and monthly aggregation, when applicable. Special attributes
in the \code{Variable} component indicate the aggregation undertaken.

In order to preserve the information of the season in annual aggregations, the attribute \code{season} is
added to the \code{Dates} component.
}
\section{Parallel Processing}{


Parallel processing is enabled using the \pkg{parallel} package.
Parallelization is undertaken by a FORK-type parallel socket cluster formed by \code{ncores}.
If \code{ncores} is not specified (default), \code{ncores} will be one less than the autodetected number of cores.
The maximum number of cores used for parallel processing can be set with the \code{max.ncores} argument,
although this will be reset to the auto-detected number of cores minus 1 if this number is exceeded. Note that not all
code, but just some critical loops within the function are parallelized.

In practice, parallelization does not always result in smaller execution times, due to the parallel overhead.
However, parallel computing may potentially provide a significant speedup for the
particular case of large multimember datasets or large grids.

Parallel computing is currently not available for Windows machines.
}
\examples{
\dontrun{
data("iberia_tasmax")
## Aggregating members
# Ensemble mean
mn <- aggregateGrid(grid = tasmax_forecast, aggr.mem = list("mean", na.rm = TRUE))
# Ensemble 90th percentile
ens90 <- aggregateGrid(grid = tasmax_forecast,
                       aggr.mem = list("quantile", probs = 0.9, na.rm = TRUE))
par(mfrow = c(1,2))
plotMeanGrid(mn)
plotMeanGrid(ens90)
par(mfrow = c(1,1))

## Monthly aggregation
monthly.mean <- aggregateGrid(tasmax_forecast, aggr.m = list(FUN = mean, na.rm = TRUE))

## Several dimensions ca be aggregated in one go:
mm.mean <- aggregateGrid(tasmax_forecast,
               aggr.mem = list(FUN = "mean", na.rm = TRUE),
               aggr.m = list(FUN = "mean", na.rm = TRUE))
}
}
\author{
M. Iturbide, M. de Felice, J. Bedia
}

